<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>kafka-component</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Kafka-component</span> <span class="project-version">0.5.11</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="README.html"><div class="inner"><span>kafka-component</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kafka-component</span></div></div></li><li class="depth-2 branch"><a href="kafka-component.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-2 branch"><a href="kafka-component.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="kafka-component.mock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#kafka-component" name="kafka-component"></a>kafka-component</h1>
<p>Provides a Kafka consumption pool component to work with Stuart Sierra’s component.</p>
<p>The consumer component will manually commit offsets after each batch of messages has been processed, instead of relying on <code>auto.commit.enable</code>. This library takes special care to make sure that messages have actually been processed before committing which the default <code>auto.commit.enable</code> doesn’t have as strong semantics. To avoid a thread committing another thread’s offsets, each thread receives its own kafka consumer.</p>
<h1><a href="#installation" name="installation"></a>Installation</h1>
<p>Add to your dependencies in your <code>project.clj</code>:</p>
<p><a href="https://clojars.org/kafka-component"><img src="https://img.shields.io/clojars/v/kafka-component.svg" alt="Clojars Project" /></a></p>
<h1><a href="#usage" name="usage"></a>Usage</h1>
<p>Use <code>KafkaWriter</code> and <code>KafkaReader</code> in a system:</p>
<pre><code class="clojure">(ns myapp
  (:require [kafka-component.core :as kafka-component]
            [com.stuartsierra.component :as component])

(def config
  {:writer-config {:native-producer-overrides {"bootstrap.servers" "localhost:9092"}}
   :reader-config {:shutdown-timeout          4 ; default
                   :concurrency-level         2
                   :topics                    ["topic_one" "or_more"]
                   :native-consumer-overrides {"bootstrap.servers" "localhost:9092"
                                               "group.id"           "myapp"
                                               "auto.offset.reset" "largest"}}})

(defn create-system [config]
  (component/system-using
    (component/system-map
      :logger            println
      :exception-handler (fn [e] (.printStackTrace e))
      :record-processor  {:process (fn [{:keys [key value]}] (println "Received message: " value))}
      :reader            (kafka-component/map-&gt;KafkaReader (config :reader-config))
      :writer            (kafka-component/map-&gt;KafkaWriter (config :writer-config)))))
    {:reader [:logger :exception-handler :record-processor]}))
</code></pre>
<h2><a href="#produce-a-message" name="produce-a-message"></a>Produce a message</h2>
<pre><code class="clojure">(let [{:keys [writer]} (component/start (create-system config))]
  (kafka-component/write writer "topic_one" "message-key" "message-body"))
</code></pre>
<p>It is also possible to <code>kakfka-component/write-async</code>.</p>
<h2><a href="#consume-a-mesage" name="consume-a-mesage"></a>Consume a mesage</h2>
<p>Because reader is listening to “topic_one”, it will deliver a message to the record-processor:</p>
<pre><code>Received message: message-body
</code></pre>
<h1><a href="#testing" name="testing"></a>Testing</h1>
<p>You can use specically designed mock implementations for tests. The mocks emulate kafka, in-memory without the large startup overhead.</p>
<pre><code class="clojure">(ns myapp.tests
  (:require [kafka-component.mock :as kafka-mock]
            [clojure.test :refer :all]))
            
(deftest basic-produce-consume
  (kafka-mock/with-test-producer-consumer producer consumer
    ;; tell mock producer to send a message on a kafka queue
    (kafka-mock/send producer "topic" "key" "value")

    ;; tell mock consumer to subscribe to topic
    (is (= [{:value "value" :key "key" :partition 0 :topic "topic" :offset 0}]
           (kafka-mock/accumulate-messages consumer "topic" {:timeout 1000})))))

(deftest transforming-messages
  (kafka-mock/with-test-producer-consumer producer consumer
    (dotimes [n 100]
      (kafka-mock/send producer "topic" "key" (str n)))

    ;; transform and filter messages
    (is (= [1 3]
           (kafka-mock/txfm-messages consumer "topic"
                                     (comp (map :value)
                                           (map #(Integer/parseInt %))
                                           (filter odd?)
                                           (take 2))
                                     {:timeout 1000})))))
</code></pre>
<p>It is also possible to <code>kafka-mock/send-async</code>.</p>
<p>The producer and consumer created by <code>with-test-producer-consumer</code> run outside of a system. To use the mocks <em>inside</em> a system, modify the system config:</p>
<pre><code class="clojure">(def test-config
  (-&gt; myapp/config
      (assoc-in [:writer-config :native-producer-type] :mock)
      (assoc-in [:reader-config :native-consumer-type] :mock)
      (assoc-in [:reader-config :native-consumer-overrides "auto.offset.reset"] "earliest")))
</code></pre>
<p>Usually, you will want to do both. * If your system has a <code>reader</code>, create messages outside of the system with a  <code>producer</code>, then test that the system reads and processes the messages  correctly. * If your system has a <code>writer</code>, poke your system to produce a message, then  test that an external <code>consumer</code> can read the message.</p></div></div></div></body></html>
